{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Data structures This MkDocs includes pages of data structures. With explanations and examples.","title":"Home"},{"location":"#data-structures","text":"This MkDocs includes pages of data structures. With explanations and examples.","title":"Data structures"},{"location":"arrays/","text":"Arrays Arrays are similar to lists, however they only collect the same data type and manage arithmetic operations better. # Creating an array of numbers numbers = [1, 2, 3, 4, 5] # Accessing array elements print(numbers[0]) # Output: 1 print(numbers[3]) # Output: 4 # Modifying array elements numbers[2] = 6 print(numbers) # Output: [1, 2, 6, 4, 5] # Appending elements to the array numbers.append(7) print(numbers) # Output: [1, 2, 6, 4, 5, 7] # Removing elements from the array numbers.remove(2) print(numbers) # Output: [1, 6, 4, 5, 7] # Length of the array print(len(numbers)) # Output: 5 # Iterating over the array for number in numbers: print(number) # Output: # 1 # 6 # 4 # 5 # 7","title":"Arrays"},{"location":"arrays/#arrays","text":"Arrays are similar to lists, however they only collect the same data type and manage arithmetic operations better. # Creating an array of numbers numbers = [1, 2, 3, 4, 5] # Accessing array elements print(numbers[0]) # Output: 1 print(numbers[3]) # Output: 4 # Modifying array elements numbers[2] = 6 print(numbers) # Output: [1, 2, 6, 4, 5] # Appending elements to the array numbers.append(7) print(numbers) # Output: [1, 2, 6, 4, 5, 7] # Removing elements from the array numbers.remove(2) print(numbers) # Output: [1, 6, 4, 5, 7] # Length of the array print(len(numbers)) # Output: 5 # Iterating over the array for number in numbers: print(number) # Output: # 1 # 6 # 4 # 5 # 7","title":"Arrays"},{"location":"graphs/","text":"Graphs Graphs are non-linear data structures made up of nodes connected by edges.","title":"Graphs"},{"location":"graphs/#graphs","text":"Graphs are non-linear data structures made up of nodes connected by edges.","title":"Graphs"},{"location":"hash/","text":"Hash tables Hash tables are data structures to map keys to corresponding values. This data structure has no order, but allows for efficient data retreival, insertion and deletion. # Creating a dictionary student = { \"name\": \"John\", \"age\": 20, \"major\": \"Computer Science\", \"gpa\": 3.5 } # Accessing dictionary values print(\"Name:\", student[\"name\"]) # Output: John print(\"GPA:\", student[\"gpa\"]) # Output: 3.5 # Modifying dictionary values student[\"age\"] = 21 student[\"gpa\"] = 3.8 print(\"Modified Age:\", student[\"age\"]) # Output: 21 print(\"Modified GPA:\", student[\"gpa\"]) # Output: 3.8 # Adding new key-value pairs student[\"university\"] = \"XYZ University\" print(\"University:\", student[\"university\"]) # Output: XYZ University # Removing key-value pairs del student[\"major\"] print(\"Major:\", student.get(\"major\")) # Output: None","title":"Hash Tables"},{"location":"hash/#hash-tables","text":"Hash tables are data structures to map keys to corresponding values. This data structure has no order, but allows for efficient data retreival, insertion and deletion. # Creating a dictionary student = { \"name\": \"John\", \"age\": 20, \"major\": \"Computer Science\", \"gpa\": 3.5 } # Accessing dictionary values print(\"Name:\", student[\"name\"]) # Output: John print(\"GPA:\", student[\"gpa\"]) # Output: 3.5 # Modifying dictionary values student[\"age\"] = 21 student[\"gpa\"] = 3.8 print(\"Modified Age:\", student[\"age\"]) # Output: 21 print(\"Modified GPA:\", student[\"gpa\"]) # Output: 3.8 # Adding new key-value pairs student[\"university\"] = \"XYZ University\" print(\"University:\", student[\"university\"]) # Output: XYZ University # Removing key-value pairs del student[\"major\"] print(\"Major:\", student.get(\"major\")) # Output: None","title":"Hash tables"},{"location":"linked/","text":"Linked Lists Linked lists are data structures in which its nodes are connected through pointers. Where each node contains data and a reference to the next node.","title":"Linked Lists"},{"location":"linked/#linked-lists","text":"Linked lists are data structures in which its nodes are connected through pointers. Where each node contains data and a reference to the next node.","title":"Linked Lists"},{"location":"lists/","text":"Lists Lists are containers that hold different data types such as integers, floats, strings etc. # Creating a list fruits = ['apple', 'banana', 'orange', 'grape'] # Accessing list elements print(fruits[0]) # Output: apple print(fruits[2]) # Output: orange # Modifying list elements fruits[1] = 'pear' print(fruits) # Output: ['apple', 'pear', 'orange', 'grape'] # Appending elements to the list fruits.append('mango') print(fruits) # Output: ['apple', 'pear', 'orange', 'grape', 'mango'] # Removing elements from the list fruits.remove('orange') print(fruits) # Output: ['apple', 'pear', 'grape', 'mango'] # Length of the list print(len(fruits)) # Output: 4 # Iterating over the list for fruit in fruits: print(fruit) # Output: # apple # pear # grape # mango","title":"Lists"},{"location":"lists/#lists","text":"Lists are containers that hold different data types such as integers, floats, strings etc. # Creating a list fruits = ['apple', 'banana', 'orange', 'grape'] # Accessing list elements print(fruits[0]) # Output: apple print(fruits[2]) # Output: orange # Modifying list elements fruits[1] = 'pear' print(fruits) # Output: ['apple', 'pear', 'orange', 'grape'] # Appending elements to the list fruits.append('mango') print(fruits) # Output: ['apple', 'pear', 'orange', 'grape', 'mango'] # Removing elements from the list fruits.remove('orange') print(fruits) # Output: ['apple', 'pear', 'grape', 'mango'] # Length of the list print(len(fruits)) # Output: 4 # Iterating over the list for fruit in fruits: print(fruit) # Output: # apple # pear # grape # mango","title":"Lists"},{"location":"queues/","text":"Queues A queue is a data structure that follows the First In First Out (FIFO) principle, where the elements that were added in first, is the first to be taken out. # Initializing a queue queue = [] # Adding elements to the queue queue.append('1') queue.append('2') queue.append('3') print(queue) #OUTPUT ['1', '2', '3'] # Removing elements from the queue print(\"\\nElements dequeued from queue\") print(queue.pop(0)) print(queue.pop(0)) print(queue.pop(0)) #OUTPUT a b c print(queue) #OUTPUT []","title":"Queues"},{"location":"queues/#queues","text":"A queue is a data structure that follows the First In First Out (FIFO) principle, where the elements that were added in first, is the first to be taken out. # Initializing a queue queue = [] # Adding elements to the queue queue.append('1') queue.append('2') queue.append('3') print(queue) #OUTPUT ['1', '2', '3'] # Removing elements from the queue print(\"\\nElements dequeued from queue\") print(queue.pop(0)) print(queue.pop(0)) print(queue.pop(0)) #OUTPUT a b c print(queue) #OUTPUT []","title":"Queues"},{"location":"sets/","text":"Sets Sets are data structures which store unique elements of the same data type in a sorted order. # Creating a Set with # a List of Numbers # (Having duplicate values) set1 = set([1, 2, 4, 4, 3, 3, 3, 6, 5]) print(\"\\nSet with the use of Numbers: \") print(set1) #OUTPUT {1, 2, 3, 4, 5, 6}","title":"Sets"},{"location":"sets/#sets","text":"Sets are data structures which store unique elements of the same data type in a sorted order. # Creating a Set with # a List of Numbers # (Having duplicate values) set1 = set([1, 2, 4, 4, 3, 3, 3, 6, 5]) print(\"\\nSet with the use of Numbers: \") print(set1) #OUTPUT {1, 2, 3, 4, 5, 6}","title":"Sets"},{"location":"stack/","text":"Stack A stack is a data structure that follows the Last In First Out (LIFO) principle, where the element that was added in last, is the first to be taken out. stack = [] # append() function to push # element in the stack stack.append('1') stack.append('2') stack.append('3') print(stack) #OUTPUT ['1', '2', '3'] # pop() function to pop # element from stack in # LIFO order print('\\nElements popped from stack:') print(stack.pop()) print(stack.pop()) print(stack.pop()) #OUTPUT 3 2 1 print('\\nStack after elements are popped:') print(stack) #OUTPUT []","title":"Stack"},{"location":"stack/#stack","text":"A stack is a data structure that follows the Last In First Out (LIFO) principle, where the element that was added in last, is the first to be taken out. stack = [] # append() function to push # element in the stack stack.append('1') stack.append('2') stack.append('3') print(stack) #OUTPUT ['1', '2', '3'] # pop() function to pop # element from stack in # LIFO order print('\\nElements popped from stack:') print(stack.pop()) print(stack.pop()) print(stack.pop()) #OUTPUT 3 2 1 print('\\nStack after elements are popped:') print(stack) #OUTPUT []","title":"Stack"},{"location":"trees/","text":"Trees Trees are data structures composed of nodes, where each node can have zero or more child nodes.","title":"Trees"},{"location":"trees/#trees","text":"Trees are data structures composed of nodes, where each node can have zero or more child nodes.","title":"Trees"}]}